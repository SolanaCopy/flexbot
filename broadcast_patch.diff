diff --git a/server.js b/server.js
index 1111111..2222222 100644
--- a/server.js
+++ b/server.js
@@ -1,6 +1,7 @@
 const express = require("express");
 const fs = require("fs");
 const path = require("path");
 const crypto = require("crypto");
+// (no new deps)

 // Public base URL for self-calls inside automation endpoints.
 // On Render you can set PUBLIC_BASE_URL=https://flexbot-qpf2.onrender.com
@@ -175,6 +176,7 @@ async function getDb() {
   if (libsqlClient) return libsqlClient;

   let url = process.env.TURSO_DATABASE_URL || process.env.DATABASE_URL;
   const authToken = process.env.TURSO_AUTH_TOKEN || process.env.DATABASE_AUTH_TOKEN;
   if (!url || !authToken) return null;
@@ -268,6 +270,7 @@ async function getDb() {
   await libsqlClient.execute(
     "CREATE TABLE IF NOT EXISTS signal_exec (" +
       "signal_id TEXT PRIMARY KEY," +
       "ticket TEXT," +
       "fill_price REAL," +
       "filled_at_ms INTEGER," +
       "filled_at_mt5 TEXT," +
       "raw_json TEXT," +
       "FOREIGN KEY(signal_id) REFERENCES signals(id)" +
     ")"
   );

+  // NEW: per-account executions (broadcast support)
+  await libsqlClient.execute(
+    "CREATE TABLE IF NOT EXISTS signal_exec2 (" +
+      "signal_id TEXT NOT NULL," +
+      "account_login TEXT NOT NULL," +
+      "server TEXT NOT NULL," +
+      "ticket TEXT," +
+      "fill_price REAL," +
+      "filled_at_ms INTEGER," +
+      "filled_at_mt5 TEXT," +
+      "ok_mod INTEGER DEFAULT 0," +
+      "raw_json TEXT," +
+      "PRIMARY KEY (signal_id, account_login, server)" +
+    ")"
+  );
+
+  await libsqlClient.execute(
+    "CREATE INDEX IF NOT EXISTS idx_exec2_signal ON signal_exec2(signal_id)"
+  );
+  await libsqlClient.execute(
+    "CREATE INDEX IF NOT EXISTS idx_exec2_account ON signal_exec2(account_login, server)"
+  );
+
+  // Best-effort migration from legacy table (safe to ignore failures)
+  try {
+    await libsqlClient.execute(
+      "INSERT OR IGNORE INTO signal_exec2 (signal_id,account_login,server,ticket,fill_price,filled_at_ms,filled_at_mt5,ok_mod,raw_json) " +
+      "SELECT signal_id,'legacy','legacy',ticket,fill_price,filled_at_ms,filled_at_mt5,1,raw_json FROM signal_exec"
+    );
+  } catch {
+    // ignore
+  }
+
   await libsqlClient.execute(
     "CREATE INDEX IF NOT EXISTS idx_signals_symbol_created ON signals(symbol, created_at_ms DESC)"
   );
   await libsqlClient.execute(
@@ -410,7 +434,7 @@ async function getAnyOpenSignalRow(db, symbol) {
   if (!db) return null;
   const sym = String(symbol || "").toUpperCase();
   const rows = await db.execute({
     sql:
       "SELECT id,symbol,status,tg_open_chat_id,tg_open_message_id,created_at_ms FROM signals " +
-      "WHERE symbol=? AND status='executed' ORDER BY created_at_ms DESC LIMIT 1",
+      "WHERE symbol=? AND status IN ('active') ORDER BY created_at_ms DESC LIMIT 1",
     args: [sym],
   });
   return rows.rows?.[0] || null;
 }
@@ -1255,6 +1279,18 @@ app.get("/signal/next", async (req, res) => {
   try {
     const symbol = req.query.symbol ? String(req.query.symbol).toUpperCase() : "XAUUSD";

+    // NEW: identify requester account (required for broadcast)
+    const account_login = req.query.account_login != null ? String(req.query.account_login).trim() : "";
+    const server = req.query.server != null ? String(req.query.server).trim() : "";
+    if (!account_login || !server) {
+      return res.status(400).json({ ok: false, error: "missing_account_identity" });
+    }
+
     const sinceRaw = req.query.since_ms != null ? String(req.query.since_ms) : null;
     const sinceMs = sinceRaw && /^\d+$/.test(sinceRaw) ? Number(sinceRaw) : 0;
     const sinceMsSafe = Number.isFinite(sinceMs) && sinceMs > 0 ? sinceMs : 0;
@@ -1279,7 +1315,7 @@ app.get("/signal/next", async (req, res) => {
     const db = await getDb();
     if (!db) return res.status(503).json({ ok: false, error: "db_required" });

     // We may need to skip/cancel stale/invalid signals ...
     const MAX_SKIP = 5;
     for (let attempt = 0; attempt < MAX_SKIP; attempt++) {
       const rows = await db.execute({
         sql:
           "SELECT id,symbol,direction,sl,tp_json,risk_pct,comment,status,created_at_ms,created_at_mt5 " +
           "FROM signals " +
-          "WHERE symbol=? AND status='new' AND created_at_ms >= ? " +
+          "WHERE symbol=? AND status IN ('new','active') AND created_at_ms >= ? " +
+          "AND NOT EXISTS (" +
+          "  SELECT 1 FROM signal_exec2 e " +
+          "  WHERE e.signal_id = signals.id " +
+          "    AND e.account_login = ? " +
+          "    AND e.server = ? " +
+          "    AND e.ok_mod = 1" +
+          ") " +
           "ORDER BY created_at_ms ASC LIMIT 1",
-        args: [symbol, minCreatedAtMs],
+        args: [symbol, minCreatedAtMs, account_login, server],
       });

       const r = rows.rows?.[0];
       if (!r) return res.json({ ok: true, signal: null });
@@ -1450,11 +1486,14 @@ app.post("/signal/closed", async (req, res) => {
     let tp = [];
     try { tp = JSON.parse(String(sig.tp_json || "[]")); } catch { tp = []; }

     const exRow = await db.execute({
-      sql: "SELECT fill_price FROM signal_exec WHERE signal_id=? LIMIT 1",
+      sql: "SELECT fill_price FROM signal_exec2 WHERE signal_id=? AND ok_mod=1 ORDER BY filled_at_ms ASC LIMIT 1",
       args: [signal_id],
     });
     const entry = exRow.rows?.[0]?.fill_price != null ? Number(exRow.rows[0].fill_price) : null;
@@ -1650,6 +1689,12 @@ app.post("/signal/executed", async (req, res) => {
     const signal_id = body?.signal_id ? String(body.signal_id) : "";
     const ticket = body?.ticket != null ? String(body.ticket) : null;
     const fill_price = body?.fill_price != null ? Number(body.fill_price) : null;
     const execDirection = body?.direction != null ? String(body.direction).toUpperCase() : null;
+    // NEW: which account executed it
+    const account_login = body?.account_login != null ? String(body.account_login).trim() : "";
+    const server = body?.server != null ? String(body.server).trim() : "";
+    if (!account_login || !server) {
+      return res.status(400).json({ ok: false, error: "missing_account_identity" });
+    }

     const okModRaw = body?.ok_mod ?? body?.okMod ?? body?.okmod;
     const ok_mod = okModRaw === true || okModRaw === 1 || okModRaw === "1" || okModRaw === "true";
@@ -1668,24 +1713,29 @@ app.post("/signal/executed", async (req, res) => {
     const db = await getDb();
     if (!db) return res.status(503).json({ ok: false, error: "db_required" });

-    // Always record execution callback so the same signal isn't re-processed.
-    await db.execute({
-      sql: "INSERT OR REPLACE INTO signal_exec (signal_id,ticket,fill_price,filled_at_ms,filled_at_mt5,raw_json) VALUES (?,?,?,?,?,?)",
-      args: [signal_id, ticket, fill_price, executed_at_ms, executed_at_mt5, JSON.stringify(body)],
-    });
+    // NEW: record per-account execution callback
+    await db.execute({
+      sql: "INSERT OR REPLACE INTO signal_exec2 (signal_id,account_login,server,ticket,fill_price,filled_at_ms,filled_at_mt5,ok_mod,raw_json) VALUES (?,?,?,?,?,?,?,?,?)",
+      args: [
+        signal_id,
+        account_login,
+        server,
+        ticket,
+        fill_price,
+        executed_at_ms,
+        executed_at_mt5,
+        ok_mod ? 1 : 0,
+        JSON.stringify(body),
+      ],
+    });

-    // Mark executed as soon as we receive an execution callback.
-    await db.execute({
-      sql: "UPDATE signals SET status='executed' WHERE id=?",
-      args: [signal_id],
-    });
+    // IMPORTANT: keep signal available for OTHER accounts until they execute too.
+    // Use status='active' to represent "open / in-flight".
+    await db.execute({
+      sql: "UPDATE signals SET status='active' WHERE id=?",
+      args: [signal_id],
+    });

     // Update EA cooldown state ONLY when EA confirms success.
     const sigRow = await db.execute({
       sql: "SELECT symbol,direction,sl,tp_json,risk_pct,comment,tg_open_chat_id,tg_open_message_id FROM signals WHERE id=? LIMIT 1",
       args: [signal_id],
     });
@@ -1785,7 +1835,7 @@ app.post("/signal/executed", async (req, res) => {
     }

-    return res.json({ ok: true, signal_id, ticket, fill_price, executed_at: executed_at_mt5, ok_mod });
+    return res.json({ ok: true, signal_id, ticket, fill_price, executed_at: executed_at_mt5, ok_mod, account_login, server });
   } catch {
     return res.status(400).json({ ok: false, error: "bad_json" });
   }
 });
